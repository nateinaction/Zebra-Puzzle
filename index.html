<html>
    <head>
        <title>
    	    Zebra Puzzle
		</title>
        <link href="./styles/computer.css" rel="stylesheet" type="text/css">
				<!--<script src="https://www.google.com/jsapi?key=ABQIAAAAFdti1WSalXCBvBGWG_B8yBTHTX3ap-9ER6gjhJqCFb29dttlmhQE4ZNjx_pdDznoaKE1sWujUJczZw"></script>-->
				<!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>-->
				<script src="./javascript/jquery-1.6.1.js"></script>
				<script src="./javascript/jquery.rightClick.js"></script>
				<script src="./javascript/game-clues.js"></script>
				<script src="./javascript/user-input.js"></script>
				<script src="./javascript/clues/directional-clues.js"></script>
				<script src="./javascript/clues/vertical-clues.js"></script>
				<script src="./javascript/clues/near-clues.js"></script>
				<script src="./javascript/clues/between-clues.js"></script>
				<!-- <script src="./javascript/solvable-check.js"></script> -->
	</head>
	<body>
	<script language="JavaScript">
		/* The Puzzle Object */
		
		// setup some variables and objects
		var	puzzle = {
					height : 3, // the height of the puzzle
					width : 6, // the width of the puzzle
					row : Array(), // generate an array of rows
					solvable : false, // set the puzzle as not solvable
					solved : Array() // generate an array filled with all puzzle.row[1 -> puzzle.height].columns[1 -> puzzle.height].solved.bool
				},
				clues = {
					between : Array(),
					directional : Array(),
					near : Array(),
					vertical : Array(),
					// define maximum number of possible rules based on puzzle size
					betweenMax : ((puzzle.height * puzzle.height) * puzzle.height) * (puzzle.width - 3),
					directionalMax :
						function directionalMax() {
							var directionalMax = 0;
							for (var x = 1; x < (puzzle.width - 1); x++) {
								directionalMax += (x * puzzle.height) * puzzle.height;
							};
							return directionalMax;
						},
					nearMax : ((puzzle.width - 1) * puzzle.height) * puzzle.height,
					verticalMax : puzzle.width * puzzle.height
				},
				clueNumber = 0,
				score = 0,
				resources = "./images/";

		if (puzzle.height >= 3 && puzzle.width >= 4) { // minimum puzzle size.
			document.write('<div class="board">');
			document.write('<span id="score">0</span>');
			for (var rowNumber = 1; rowNumber <= puzzle.height; rowNumber++) { // for all rows
				puzzle.row[rowNumber] = {
					column : Array(), // generate an array of columns
					answers : Array() // generate an array of answers
				};
				document.write('<div class="row">');
				for (var columnNumber = 1; columnNumber <= puzzle.width; columnNumber++) { // for all columns
					// create answers
					var randomAnswer = (Math.floor(Math.random() * puzzle.width)) + 1; // generate a random answer to be used for the column
					if (puzzle.row[rowNumber].answers.indexOf(randomAnswer) != -1) { // if the answer has already been used by another column in the row...
						while (puzzle.row[rowNumber].answers.indexOf(randomAnswer) != -1) { // continue generating random answers until an unused answer is generated
							randomAnswer = (Math.floor(Math.random() * puzzle.width)) + 1;
						};
					};
					puzzle.row[rowNumber].answers.push(randomAnswer);
					// then...
					puzzle.row[rowNumber].column[columnNumber] = {
						solvable : { // set all columns as unsolvable
							string : 'unsolvable', // set the string of the column as unsolvable
							bool : false // set the boolean value of an unsolvable column as false
						},
						solved : { // set all columns as unsolved
							string : 'unsolved', // set the string of the column as unsolved
							bool : false // set the boolean value of an unsolved column as false
						},
						answer : randomAnswer, // placeholder for the column answer
						tile : Array() // then generate an array of tiles
					};
					// puzzle.row[rowNumber].answer[columnNumber] = puzzle.row[rowNumber].column[columnNumber].answer; // set all array elements in puzzle.answer to match puzzle.row[1 -> puzzle.height].columns[1 -> puzzle.height].solvable.bool
					// puzzle.solvable[((rowNumber - 1) * puzzle.width) + columnNumber] = puzzle.row[rowNumber].column[columnNumber].solvable.bool; // set all array elements in puzzle.solvable to match puzzle.row[1 -> puzzle.height].columns[1 -> puzzle.height].solvable.bool 
					puzzle.solved[((rowNumber - 1) * puzzle.width) + columnNumber] = puzzle.row[rowNumber].column[columnNumber].solved.bool; // set all array elements in puzzle.solved to match puzzle.row[1 -> puzzle.height].columns[1 -> puzzle.height].solved.bool
					document.write('<div class="column">');
					document.write('<div class="padding">');
					for (var tileNumber = 1; tileNumber <= puzzle.width; tileNumber++) { // for all tiles
						puzzle.row[rowNumber].column[columnNumber].tile[tileNumber] = {
							flag : { // set all tiles as unflagged
								string : 'unflagged', // set the string of the tile as unflagged
								bool : false // set the boolean value of an unflagged tile as false
							},
							possible : { // set all tiles as possible
								string : 'possible', // set the string of the tile as possible
								bool : true // set the boolean value of a possible tile as true
							},
							answer : { // set all tiles as incorrect
								string : 'incorrect', // set the string of the tile as incorrect
								bool : false // set the boolean value of an incorrect tile as false
							}
						};
						if (puzzle.row[rowNumber].column[columnNumber].answer == tileNumber) { // if this tile is the answer for the column
							puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].answer.string = 'correct'; // set the string of the tile as correct
							puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].answer.bool = true; // set the boolean value of a correct tile as true
						};
						document.write('<div id="' + rowNumber + columnNumber + tileNumber + '" style="background-image:url(' + resources + 'row' + rowNumber + '/' + tileNumber + '.jpg);" class="' + puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.string + '"></div>');
						$("#" + rowNumber + columnNumber + tileNumber).click(function(rowNumber, columnNumber, tileNumber) {
							return function() {
								userInput(rowNumber, columnNumber, tileNumber);
							};
						}(rowNumber, columnNumber, tileNumber));
						function rightClick(rowNumber, columnNumber, tileNumber) {
							console.log(event);
						}
						$("#" + rowNumber + columnNumber + tileNumber).rightClick( function(puzzle) {
							if (this.hasClass("flagged") == true) {
								$(this).removeClass("flagged");
								console.log(event);
								return function() {
									puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.string = 'unflagged';
									puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.bool = false;
									console.log(puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.string);
								};
							}
							else if (this.hasClass("unflagged") == true && this.hasClass("correct") == false) {
								$(this).addClass("flagged");
								return function() {
									puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.string = 'flagged';
									puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.bool = true;
									console.log(puzzle.row[rowNumber].column[columnNumber].tile[tileNumber].flag.string);
								};
							};
						});
					};
					document.write('</div>');
					document.write('</div>');
				};
				document.write('</div>');
				console.log(puzzle.row[rowNumber].answers);
			};
			document.write('</div>');
			document.write('<div class="horizontalClueArea"></div>');
			document.write('<div class="verticalClueArea"></div>');
			
			for (false in puzzle.row[1].column[1].solvable.bool) {
				console.log('test');
			}
			
			// generate clues
			for (var x=0;x<=27;x++){
				//randomClue();
			};
		}
		else {
			console.log("Puzzle size too small, please choose 3x4 or higher.");
		};
		</script>
		<script src="./javascript/clues/clue-engine.js"></script>
	</body>
</html>